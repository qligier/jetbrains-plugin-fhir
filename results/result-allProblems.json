{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'null' is returned by the method declared as @NotNull",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/igini/IgIniFileType.java",
      "language": "JAVA",
      "line": 33,
      "offset": 16,
      "length": 4,
      "code": {
        "startLine": 31,
        "length": 4,
        "offset": 76,
        "surroundingCode": "    @Override\n    public @NonNls @NotNull String getName() {\n        return null;\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "d53162c8058fec1147760b0c13619c2195a7475559a93311572aedb01267963f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'null' is returned by the method declared as @NotNull",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/igini/IgIniFileType.java",
      "language": "JAVA",
      "line": 49,
      "offset": 16,
      "length": 4,
      "code": {
        "startLine": 47,
        "length": 4,
        "offset": 89,
        "surroundingCode": "    @Override\n    public @NlsSafe @NotNull String getDefaultExtension() {\n        return null;\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "c147e00221e569b50d25b0879db3c24ce3d638a2ff738be3c8e28fe910f290f8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'null' is returned by the method declared as @NotNull",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/igini/IgIniFileType.java",
      "language": "JAVA",
      "line": 41,
      "offset": 16,
      "length": 4,
      "code": {
        "startLine": 39,
        "length": 4,
        "offset": 94,
        "surroundingCode": "    @Override\n    public @NlsContexts.Label @NotNull String getDescription() {\n        return null;\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "3582478b18f938355cab2896fbf0e8121972f2e36b234837c2d4a60ae08867bd"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Commented out code",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Commented out code (2 lines)",
  "detailsInfo": "Reports comments that contain Java code.\n\nUsually, code that is commented out gets outdated very quickly and becomes misleading.\nAs most projects use some kind of version control system,\nit is better to delete commented out code completely and use the VCS history instead.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/fsh/highlighter/FshSyntaxHighlighter.java",
      "language": "JAVA",
      "line": 113,
      "offset": 1,
      "length": 2,
      "code": {
        "startLine": 111,
        "length": 2,
        "offset": 95,
        "surroundingCode": "        } else if (FshTypes.LINECOMMENT.equals(type)) {\n            return pack(LINE_COMMENT);\n/*\n            case FshTypes.COMMENT:\n                return pack(BLOCK_COMMENT);"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "CommentedOutCode"
  },
  "hash": "1144a49bdffc1048c71b0c29fa0d312a0e04d072f41512c65795943cd83cc15a"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsSafe' is marked unstable with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/igini/IgIniFileType.java",
      "language": "JAVA",
      "line": 48,
      "offset": 13,
      "length": 7,
      "code": {
        "startLine": 46,
        "length": 7,
        "offset": 34,
        "surroundingCode": "     */\n    @Override\n    public @NlsSafe @NotNull String getDefaultExtension() {\n        return null;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "b440378393cb84ac51a1c9feec9e9350da0ee2fd35efff2247e733a2c80bdc05"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsContexts' is marked unstable with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/igini/IgIniFileType.java",
      "language": "JAVA",
      "line": 40,
      "offset": 13,
      "length": 11,
      "code": {
        "startLine": 38,
        "length": 11,
        "offset": 34,
        "surroundingCode": "     */\n    @Override\n    public @NlsContexts.Label @NotNull String getDescription() {\n        return null;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "a287e37d0970cae7f197c720c306bd2acff9dd6c0afa397c6019fbd276a95c86"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsContexts.Label' is declared in unstable class 'com.intellij.openapi.util.NlsContexts' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/igini/IgIniFileType.java",
      "language": "JAVA",
      "line": 40,
      "offset": 25,
      "length": 5,
      "code": {
        "startLine": 38,
        "length": 5,
        "offset": 46,
        "surroundingCode": "     */\n    @Override\n    public @NlsContexts.Label @NotNull String getDescription() {\n        return null;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "5a96135d521e814d3704ffa3f038748efef197e0e9807aea75da604541e4af5f"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Overridden method 'onFileChosen(com.intellij.openapi.vfs.@org.jetbrains.annotations.NotNull VirtualFile)' is declared in unstable class 'com.intellij.openapi.ui.BrowseFolderRunnable' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/configuration/IgPublisherSettingsEditor.java",
      "language": "JAVA",
      "line": 147,
      "offset": 28,
      "length": 12,
      "code": {
        "startLine": 145,
        "length": 12,
        "offset": 143,
        "surroundingCode": "                                                                                    false)) {\n            @Override\n            protected void onFileChosen(@NotNull final VirtualFile chosenFile) {\n                super.onFileChosen(chosenFile);\n                ComponentValidator.getInstance(parentThis.textFieldJarPath).ifPresent(ComponentValidator::revalidate);"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "fe87525fd9f36ede8c1eacbb784f74ae9d9b9b0c14411ba092367e489490a6af"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'onFileChosen(com.intellij.openapi.vfs.@org.jetbrains.annotations.NotNull VirtualFile)' is declared in unstable class 'com.intellij.openapi.ui.BrowseFolderRunnable' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/ch/qligier/jetbrains/plugin/fhir/configuration/IgPublisherSettingsEditor.java",
      "language": "JAVA",
      "line": 148,
      "offset": 23,
      "length": 12,
      "code": {
        "startLine": 146,
        "length": 12,
        "offset": 125,
        "surroundingCode": "            @Override\n            protected void onFileChosen(@NotNull final VirtualFile chosenFile) {\n                super.onFileChosen(chosenFile);\n                ComponentValidator.getInstance(parentThis.textFieldJarPath).ifPresent(ComponentValidator::revalidate);\n                updateIgPublisherStatus();"
      }
    }
  ],
  "attributes": {
    "module": "jetbrains-plugin-fhir.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "ef1697eceaf6c5c772bf718ab69dfc46a6a28ca7e43d038e31a233faa9fd9537"
}]}